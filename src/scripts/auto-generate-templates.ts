#!/usr/bin/env node

/**
 * Script to automatically generate the templates.ts file
 * This scans the docs directory and updates the static template list
 */

import fs from "fs";
import path from "path";

// Define the template type for generation
interface TemplateData {
	name: string;
	title: string;
	description: string;
	type: string;
	path: string;
	dependencies: string[];
	files?: {
		path: string;
		name: string;
		content: string;
		type: string;
	}[];
}

// Function to automatically generate templates from docs directory
function generateTemplatesFromDocs(basePath: string) {
	const templatesPath = path.join(basePath, "../app/templates");
	const templates: TemplateData[] = [];

	try {
		// Read all directories in the templates folder
		const templatesEntries = fs.readdirSync(templatesPath, {
			withFileTypes: true,
		});

		for (const entry of templatesEntries) {
			if (entry.isDirectory()) {
				const templateName = entry.name;

				// Convert kebab-case to Title Case
				const title = templateName
					.split("-")
					.map((word: string) => word.charAt(0).toUpperCase() + word.slice(1))
					.join(" ");

				// Generate description based on template name
				const description = `A minimalistic ${templateName.replace("-", " ")} template designed with React and Tailwind CSS.`;

				const templateContent = fs.readFileSync(
					`../app/templates/${templateName}/${templateName}.tsx`,
					"utf-8",
				);

				templates.push({
					name: templateName,
					title: title,
					description: description,
					type: "registry:template",
					path: `../app/templates/${templateName}`,
					dependencies: [],
					files: [
						{
							path: `../app/templates/${templateName}`,
							name: templateName,
							content: templateContent,
							type: "registry:template",
						},
					],
				});
			}
		}
	} catch (error) {
		console.error("Error reading docs directory:", error);
		process.exit(1);
	}

	return templates.sort((a, b) => a.name.localeCompare(b.name));
}

// Generate the templates.ts file content
function generateTemplatesFile(basePath: string) {
	const templates = generateTemplatesFromDocs(basePath);

	const fileContent = `import { RegistryItemSchema, RegistryType } from "./types";

type TemplateType = Omit<
  RegistryItemSchema,
  "$schema" | "files" | "type" | "author"
> &
  Partial<Pick<RegistryItemSchema, "type" | "author">> & {
    path: string;
    files?: {
      path: string;
      name: string;
      content: string;
      type: RegistryType;
    }[];
  };

// Static template list - this is auto-generated by the build script
export const templates: TemplateType[] = [
${templates
			.map(
				(template) => `  {
    name: "${template.name}",
    title: "${template.title}",
    description: "${template.description}",
    type: "${template.type}",
    path: "${template.path}",
    dependencies: [],
    files: [
      {
        path: "${template.path}",
        name: "${template.name}",
        content: "${template.files?.[0].content}",
        type: "${template.type}",
      },
    ],
  }`,
			)
			.join(",\n")}
];
`;

	return fileContent;
}

// Main execution
console.log("üîÑ Auto-generating templates.ts file...");

try {
	const newContent = generateTemplatesFile(__dirname);
	const templatesFilePath = path.join(__dirname, "templates.ts");

	fs.writeFileSync(templatesFilePath, newContent);

	console.log("‚úÖ templates.ts file updated successfully!");
	console.log(`üìÅ Updated: ${templatesFilePath}`);
} catch (error) {
	console.error("‚ùå Error generating templates.ts:", error);
	process.exit(1);
}
