#!/usr/bin/env node

/**
 * Script to automatically generate the templates.ts file
 * This scans the docs directory and updates the static template list
 */

import fs from "fs";
import path from "path";

// Define the template type for generation
interface TemplateData {
	name: string;
	title: string;
	description: string;
	type: string;
	path: string;
	dependencies: string[];
}

// Function to automatically generate templates from docs directory
function generateTemplatesFromDocs(basePath: string) {
	const templatesPath = path.join(basePath, "../app/templates");
	const templates: TemplateData[] = [];

	try {
		// Read all directories in the templates folder
		const templatesEntries = fs.readdirSync(templatesPath, {
			withFileTypes: true,
		});

		for (const entry of templatesEntries) {
			if (entry.isDirectory()) {
				const templateName = entry.name;

				// Convert kebab-case to Title Case
				const title = templateName
					.split("-")
					.map((word: string) => word.charAt(0).toUpperCase() + word.slice(1))
					.join(" ");

				// Generate description based on template name
				const description = `A minimalistic ${templateName.replace("-", " ")} template designed with React and Tailwind CSS.`;

				// Custom descriptions for specific templates
				// const customDescriptions: Record<string, string> = {
				// 	templateName:
				// 		"custom description for templateName",
				// };

				// if (customDescriptions[templateName]) {
				// 	description = customDescriptions[templateName];
				// }

				templates.push({
					name: templateName,
					title: title,
					description: description,
					type: "registry:template",
					path: `../app/templates/${templateName}`,
					dependencies: [],
				});
			}
		}
	} catch (error) {
		console.error("Error reading docs directory:", error);
		process.exit(1);
	}

	return templates.sort((a, b) => a.name.localeCompare(b.name));
}

// Generate the templates.ts file content
function generateTemplatesFile(basePath: string) {
	const templates = generateTemplatesFromDocs(basePath);

	const fileContent = `import { RegistryItemSchema, RegistryType } from "./types";

type TemplateType = Omit<
  RegistryItemSchema,
  "$schema" | "files" | "type" | "author"
> &
  Partial<Pick<RegistryItemSchema, "type" | "author">> & {
    path: string;
    files?: {
      path: string;
      name: string;
      content: string;
      type: RegistryType;
    }[];
  };

// Static template list - this is auto-generated by the build script
export const templates: TemplateType[] = [
${templates
			.map(
				(template) => `  {
    name: "${template.name}",
    title: "${template.title}",
    description: "${template.description}",
    type: "${template.type}",
    path: "${template.path}",
    dependencies: [],
  }`,
			)
			.join(",\n")}
];
`;

	return fileContent;
}

// Main execution
console.log("üîÑ Auto-generating templates.ts file...");

try {
	const newContent = generateTemplatesFile(__dirname);
	const templatesFilePath = path.join(__dirname, "templates.ts");

	fs.writeFileSync(templatesFilePath, newContent);

	console.log("‚úÖ templates.ts file updated successfully!");
	console.log(`üìÅ Updated: ${templatesFilePath}`);
} catch (error) {
	console.error("‚ùå Error generating templates.ts:", error);
	process.exit(1);
}
