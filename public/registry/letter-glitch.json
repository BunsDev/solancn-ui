{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "letter-glitch",
  "title": "Letter Glitch",
  "description": "A minimalistic letter glitch component designed with React and Tailwind CSS.",
  "author": "Reche Soares",
  "type": "registry:ui",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "cssVars": {
    "dark": {},
    "light": {}
  },
  "files": [
    {
      "path": "letter-glitch.tsx",
      "content": "\"use client\";\nimport { useRef, useEffect, useCallback } from \"react\";\n\nconst FONT_SIZE = 16;\nconst CHAR_WIDTH = 10;\nconst CHAR_HEIGHT = 20;\nconst CHARACTER_SET =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*()-_{}[]:;<>,.?/\";\nclass Particle {\n  x: number;\n  y: number;\n  char: string;\n  initialColor: string;\n  currentColor: string;\n  targetColor: string;\n  colorProgress: number;\n\n  constructor(\n    x: number,\n    y: number,\n    char: string,\n    color: string,\n    targetColor: string\n  ) {\n    this.x = x;\n    this.y = y;\n    this.char = char;\n    this.initialColor = color;\n    this.currentColor = color;\n    this.targetColor = targetColor;\n    this.colorProgress = 1.0; // Start fully at the initial color\n  }\n\n  // Draws the particle on the canvas\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.fillStyle = this.currentColor;\n    ctx.fillText(this.char, this.x, this.y);\n  }\n\n  // Assigns a new random character\n  randomizeCharacter() {\n    this.char = CHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\n  }\n\n  // Sets a new target color to transition towards\n  setNewTargetColor(newColor: string, smooth: boolean) {\n    if (!smooth) {\n      this.currentColor = newColor;\n      this.targetColor = newColor;\n      this.colorProgress = 1.0;\n    } else {\n      this.initialColor = this.currentColor;\n      this.targetColor = newColor;\n      this.colorProgress = 0.0;\n    }\n  }\n\n  // Updates the color transition if needed\n  updateColorTransition(): boolean {\n    if (this.colorProgress >= 1) return false;\n\n    this.colorProgress = Math.min(this.colorProgress + 0.05, 1);\n\n    const start = ColorUtils.hexToRgb(this.initialColor);\n    const end = ColorUtils.hexToRgb(this.targetColor);\n\n    if (start && end) {\n      this.currentColor = ColorUtils.interpolateRgb(\n        start,\n        end,\n        this.colorProgress\n      );\n    }\n    return true; // Indicates a change was made\n  }\n}\n\n// ================================================================================\n// Utility Functions\n// A collection of pure helper functions.\n// ================================================================================\ninterface RgbColor {\n  r: number;\n  g: number;\n  b: number;\n}\n\nconst ColorUtils = {\n  // A different implementation of hex-to-rgb conversion\n  hexToRgb(hex: string): RgbColor | null {\n    if (!hex || hex.charAt(0) !== \"#\") return null;\n    const cleanHex = hex.substring(1);\n\n    // Handle 3-digit hex\n    const fullHex =\n      cleanHex.length === 3\n        ? cleanHex\n            .split(\"\")\n            .map((c: string) => c + c)\n            .join(\"\")\n        : cleanHex;\n\n    if (fullHex.length !== 6) return null;\n\n    return {\n      r: parseInt(fullHex.substring(0, 2), 16),\n      g: parseInt(fullHex.substring(2, 4), 16),\n      b: parseInt(fullHex.substring(4, 6), 16),\n    };\n  },\n  // Interpolates between two RGB colors\n  interpolateRgb(start: RgbColor, end: RgbColor, factor: number): string {\n    const r = Math.round(start.r + (end.r - start.r) * factor);\n    const g = Math.round(start.g + (end.g - start.g) * factor);\n    const b = Math.round(start.b + (end.b - start.b) * factor);\n    return `rgb(${r}, ${g}, ${b})`;\n  },\n  // Picks a random color from the provided array\n  getRandomColor(colors: string[]): string {\n    return colors[Math.floor(Math.random() * colors.length)];\n  },\n};\n\ninterface AnimationOptions {\n  colors?: string[];\n  speed?: number;\n  smooth?: boolean;\n}\n\nconst useMatrixAnimation = (\n  canvasRef: React.RefObject<HTMLCanvasElement | null>,\n  options: AnimationOptions\n) => {\n  const {\n    colors = [\"#2b4539\", \"#61dca3\", \"#61b3dc\"],\n    speed = 50,\n    smooth = true,\n  } = options;\n\n  // Using refs to store animation state without causing re-renders\n  const particlesRef = useRef<Particle[]>([]);\n  const animationFrameId = useRef<number | null>(null);\n  const lastUpdateTime = useRef<number>(0);\n  const contextRef = useRef<CanvasRenderingContext2D | null>(null);\n\n  // Memoize the getRandomColor function to ensure stability\n  const getRandomColorMemoized = useCallback(\n    () => ColorUtils.getRandomColor(colors),\n    [colors]\n  );\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const context = canvas.getContext(\"2d\", { willReadFrequently: true });\n    if (!context) return;\n    contextRef.current = context;\n\n    const grid = { cols: 0, rows: 0 };\n\n    // This function initializes or re-initializes the particle grid\n    const setup = (width: number, height: number) => {\n      const dpr = window.devicePixelRatio || 1;\n      canvas.width = width * dpr;\n      canvas.height = height * dpr;\n      canvas.style.width = `${width}px`;\n      canvas.style.height = `${height}px`;\n      context.setTransform(dpr, 0, 0, dpr, 0, 0);\n\n      context.font = `${FONT_SIZE}px monospace`;\n      context.textBaseline = \"top\";\n\n      grid.cols = Math.ceil(width / CHAR_WIDTH);\n      grid.rows = Math.ceil(height / CHAR_HEIGHT);\n\n      particlesRef.current = [];\n      for (let row = 0; row < grid.rows; row++) {\n        for (let col = 0; col < grid.cols; col++) {\n          const x = col * CHAR_WIDTH;\n          const y = row * CHAR_HEIGHT;\n          const char =\n            CHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\n          const color = getRandomColorMemoized();\n          const targetColor = getRandomColorMemoized();\n          particlesRef.current.push(\n            new Particle(x, y, char, color, targetColor)\n          );\n        }\n      }\n    };\n\n    // The main animation loop\n    const animate = (timestamp: number) => {\n      let needsRedraw = false;\n      const elapsed = timestamp - lastUpdateTime.current;\n\n      // Update a batch of particles based on the speed setting\n      if (elapsed > speed) {\n        const updateCount = Math.max(\n          1,\n          Math.floor(particlesRef.current.length * 0.05)\n        );\n        for (let i = 0; i < updateCount; i++) {\n          const index = Math.floor(Math.random() * particlesRef.current.length);\n          const particle = particlesRef.current[index];\n          if (particle) {\n            particle.randomizeCharacter();\n            particle.setNewTargetColor(getRandomColorMemoized(), smooth);\n          }\n        }\n        lastUpdateTime.current = timestamp;\n        needsRedraw = true;\n      }\n\n      // Handle smooth color transitions for any active particles\n      if (smooth) {\n        particlesRef.current.forEach((p) => {\n          if (p.updateColorTransition()) {\n            needsRedraw = true;\n          }\n        });\n      }\n\n      // Only redraw the canvas if something has changed\n      if (needsRedraw) {\n        const canvasWidth = canvas.width / (window.devicePixelRatio || 1);\n        const canvasHeight = canvas.height / (window.devicePixelRatio || 1);\n        context.clearRect(0, 0, canvasWidth, canvasHeight);\n        particlesRef.current.forEach((p) => p.draw(context));\n      }\n\n      animationFrameId.current = requestAnimationFrame(animate);\n    };\n\n    // Use ResizeObserver for efficient resize handling\n    const resizeObserver = new ResizeObserver((entries) => {\n      if (!entries || entries.length === 0) return;\n      const { width, height } = entries[0].contentRect;\n      setup(width, height);\n    });\n\n    if (canvas.parentElement) {\n      resizeObserver.observe(canvas.parentElement);\n    }\n\n    // Start the animation\n    animate(0);\n\n    // Cleanup function to stop the animation and observer\n    return () => {\n      if (animationFrameId.current) {\n        cancelAnimationFrame(animationFrameId.current);\n      }\n      resizeObserver.disconnect();\n    };\n  }, [colors, speed, smooth, canvasRef, getRandomColorMemoized]); // Dependencies for the effect\n};\n\ninterface LetterGlitchProps {\n  glitchColors: string[];\n  glitchSpeed: number;\n  smooth: boolean;\n  centerVignette?: boolean;\n  outerVignette?: boolean;\n}\n\nconst LetterGlitch = ({\n  glitchColors,\n  glitchSpeed,\n  smooth,\n  centerVignette = false,\n  outerVignette = true,\n}: LetterGlitchProps) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  // The custom hook handles all the complex animation logic\n  useMatrixAnimation(canvasRef, {\n    colors: glitchColors,\n    speed: glitchSpeed,\n    smooth: smooth,\n  });\n\n  return (\n    <div className=\"relative w-full h-full bg-black overflow-hidden\">\n      <canvas ref={canvasRef} className=\"block w-full h-full\" />\n      {/* Vignette overlays for visual effect */}\n      {outerVignette && (\n        <div className=\"absolute inset-0 pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0)_60%,_rgba(0,0,0,1)_100%)]\"></div>\n      )}\n      {centerVignette && (\n        <div className=\"absolute inset-0 pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0.8)_0%,_rgba(0,0,0,0)_60%)]\"></div>\n      )}\n    </div>\n  );\n};\n\n// ================================================================================\n// Wrapper / Example Implementation\n// This component demonstrates how to use the MatrixRain component.\n// ================================================================================\nexport default function LetterGlitchWrapper() {\n  return (\n    <div className=\"w-full h-[400px]\">\n      <LetterGlitch\n        glitchColors={[\n          \"#32a852\", // green\n          \"#4287f5\", // blue\n          \"#d942f5\", // purple\n          \"#f54242\", // red\n          \"#f5e342\", // yellow\n          \"#42f5f5\", // cyan\n          \"#f5a142\", // orange\n        ]}\n        glitchSpeed={50}\n        smooth={true}\n        outerVignette={true}\n        centerVignette={false}\n      />\n    </div>\n  );\n}\n",
      "type": "registry:ui"
    }
  ]
}