{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "letter-glitch",
  "title": "Letter Glitch",
  "description": "A minimalistic letter glitch component designed with React and Tailwind CSS.",
  "author": "Reche Soares",
  "type": "registry:component",
  "dependencies": [],
  "files": [
    {
      "path": "letter-glitch.tsx",
      "content": "\"use client\";\nimport { useCallback, useEffect, useRef } from \"react\";\n\nconst FONT_SIZE = 16;\nconst CHAR_WIDTH = 10;\nconst CHAR_HEIGHT = 20;\nconst CHARACTER_SET =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*()-_{}[]:;<>,.?/\";\nclass Particle {\n\tx: number;\n\ty: number;\n\tchar: string;\n\tinitialColor: string;\n\tcurrentColor: string;\n\ttargetColor: string;\n\tcolorProgress: number;\n\n\tconstructor(\n\t\tx: number,\n\t\ty: number,\n\t\tchar: string,\n\t\tcolor: string,\n\t\ttargetColor: string,\n\t) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.char = char;\n\t\tthis.initialColor = color;\n\t\tthis.currentColor = color;\n\t\tthis.targetColor = targetColor;\n\t\tthis.colorProgress = 1.0; // Start fully at the initial color\n\t}\n\n\t// Draws the particle on the canvas\n\tdraw(ctx: CanvasRenderingContext2D) {\n\t\tctx.fillStyle = this.currentColor;\n\t\tctx.fillText(this.char, this.x, this.y);\n\t}\n\n\t// Assigns a new random character\n\trandomizeCharacter() {\n\t\tthis.char = CHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\n\t}\n\n\t// Sets a new target color to transition towards\n\tsetNewTargetColor(newColor: string, smooth: boolean) {\n\t\tif (!smooth) {\n\t\t\tthis.currentColor = newColor;\n\t\t\tthis.targetColor = newColor;\n\t\t\tthis.colorProgress = 1.0;\n\t\t} else {\n\t\t\tthis.initialColor = this.currentColor;\n\t\t\tthis.targetColor = newColor;\n\t\t\tthis.colorProgress = 0.0;\n\t\t}\n\t}\n\n\t// Updates the color transition if needed\n\tupdateColorTransition(): boolean {\n\t\tif (this.colorProgress >= 1) return false;\n\n\t\tthis.colorProgress = Math.min(this.colorProgress + 0.05, 1);\n\n\t\tconst start = ColorUtils.hexToRgb(this.initialColor);\n\t\tconst end = ColorUtils.hexToRgb(this.targetColor);\n\n\t\tif (start && end) {\n\t\t\tthis.currentColor = ColorUtils.interpolateRgb(\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tthis.colorProgress,\n\t\t\t);\n\t\t}\n\t\treturn true; // Indicates a change was made\n\t}\n}\n\n// ================================================================================\n// Utility Functions\n// A collection of pure helper functions.\n// ================================================================================\ninterface RgbColor {\n\tr: number;\n\tg: number;\n\tb: number;\n}\n\nconst ColorUtils = {\n\t// A different implementation of hex-to-rgb conversion\n\thexToRgb(hex: string): RgbColor | null {\n\t\tif (!hex || hex.charAt(0) !== \"#\") return null;\n\t\tconst cleanHex = hex.substring(1);\n\n\t\t// Handle 3-digit hex\n\t\tconst fullHex =\n\t\t\tcleanHex.length === 3\n\t\t\t\t? cleanHex\n\t\t\t\t\t\t.split(\"\")\n\t\t\t\t\t\t.map((c: string) => c + c)\n\t\t\t\t\t\t.join(\"\")\n\t\t\t\t: cleanHex;\n\n\t\tif (fullHex.length !== 6) return null;\n\n\t\treturn {\n\t\t\tr: parseInt(fullHex.substring(0, 2), 16),\n\t\t\tg: parseInt(fullHex.substring(2, 4), 16),\n\t\t\tb: parseInt(fullHex.substring(4, 6), 16),\n\t\t};\n\t},\n\t// Interpolates between two RGB colors\n\tinterpolateRgb(start: RgbColor, end: RgbColor, factor: number): string {\n\t\tconst r = Math.round(start.r + (end.r - start.r) * factor);\n\t\tconst g = Math.round(start.g + (end.g - start.g) * factor);\n\t\tconst b = Math.round(start.b + (end.b - start.b) * factor);\n\t\treturn `rgb(${r}, ${g}, ${b})`;\n\t},\n\t// Picks a random color from the provided array\n\tgetRandomColor(colors: string[]): string {\n\t\treturn colors[Math.floor(Math.random() * colors.length)];\n\t},\n};\n\ninterface AnimationOptions {\n\tcolors?: string[];\n\tspeed?: number;\n\tsmooth?: boolean;\n}\n\nconst useMatrixAnimation = (\n\tcanvasRef: React.RefObject<HTMLCanvasElement | null>,\n\toptions: AnimationOptions,\n) => {\n\tconst {\n\t\tcolors = [\"#2b4539\", \"#61dca3\", \"#61b3dc\"],\n\t\tspeed = 50,\n\t\tsmooth = true,\n\t} = options;\n\n\t// Using refs to store animation state without causing re-renders\n\tconst particlesRef = useRef<Particle[]>([]);\n\tconst animationFrameId = useRef<number | null>(null);\n\tconst lastUpdateTime = useRef<number>(0);\n\tconst contextRef = useRef<CanvasRenderingContext2D | null>(null);\n\n\t// Memoize the getRandomColor function to ensure stability\n\tconst getRandomColorMemoized = useCallback(\n\t\t() => ColorUtils.getRandomColor(colors),\n\t\t[colors],\n\t);\n\n\tuseEffect(() => {\n\t\tconst canvas = canvasRef.current;\n\t\tif (!canvas) return;\n\n\t\tconst context = canvas.getContext(\"2d\", { willReadFrequently: true });\n\t\tif (!context) return;\n\t\tcontextRef.current = context;\n\n\t\tconst grid = { cols: 0, rows: 0 };\n\n\t\t// This function initializes or re-initializes the particle grid\n\t\tconst setup = (width: number, height: number) => {\n\t\t\tconst dpr = window.devicePixelRatio || 1;\n\t\t\tcanvas.width = width * dpr;\n\t\t\tcanvas.height = height * dpr;\n\t\t\tcanvas.style.width = `${width}px`;\n\t\t\tcanvas.style.height = `${height}px`;\n\t\t\tcontext.setTransform(dpr, 0, 0, dpr, 0, 0);\n\n\t\t\tcontext.font = `${FONT_SIZE}px monospace`;\n\t\t\tcontext.textBaseline = \"top\";\n\n\t\t\tgrid.cols = Math.ceil(width / CHAR_WIDTH);\n\t\t\tgrid.rows = Math.ceil(height / CHAR_HEIGHT);\n\n\t\t\tparticlesRef.current = [];\n\t\t\tfor (let row = 0; row < grid.rows; row++) {\n\t\t\t\tfor (let col = 0; col < grid.cols; col++) {\n\t\t\t\t\tconst x = col * CHAR_WIDTH;\n\t\t\t\t\tconst y = row * CHAR_HEIGHT;\n\t\t\t\t\tconst char =\n\t\t\t\t\t\tCHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\n\t\t\t\t\tconst color = getRandomColorMemoized();\n\t\t\t\t\tconst targetColor = getRandomColorMemoized();\n\t\t\t\t\tparticlesRef.current.push(\n\t\t\t\t\t\tnew Particle(x, y, char, color, targetColor),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// The main animation loop\n\t\tconst animate = (timestamp: number) => {\n\t\t\tlet needsRedraw = false;\n\t\t\tconst elapsed = timestamp - lastUpdateTime.current;\n\n\t\t\t// Update a batch of particles based on the speed setting\n\t\t\tif (elapsed > speed) {\n\t\t\t\tconst updateCount = Math.max(\n\t\t\t\t\t1,\n\t\t\t\t\tMath.floor(particlesRef.current.length * 0.05),\n\t\t\t\t);\n\t\t\t\tfor (let i = 0; i < updateCount; i++) {\n\t\t\t\t\tconst index = Math.floor(Math.random() * particlesRef.current.length);\n\t\t\t\t\tconst particle = particlesRef.current[index];\n\t\t\t\t\tif (particle) {\n\t\t\t\t\t\tparticle.randomizeCharacter();\n\t\t\t\t\t\tparticle.setNewTargetColor(getRandomColorMemoized(), smooth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastUpdateTime.current = timestamp;\n\t\t\t\tneedsRedraw = true;\n\t\t\t}\n\n\t\t\t// Handle smooth color transitions for any active particles\n\t\t\tif (smooth) {\n\t\t\t\tparticlesRef.current.forEach((p) => {\n\t\t\t\t\tif (p.updateColorTransition()) {\n\t\t\t\t\t\tneedsRedraw = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Only redraw the canvas if something has changed\n\t\t\tif (needsRedraw) {\n\t\t\t\tconst canvasWidth = canvas.width / (window.devicePixelRatio || 1);\n\t\t\t\tconst canvasHeight = canvas.height / (window.devicePixelRatio || 1);\n\t\t\t\tcontext.clearRect(0, 0, canvasWidth, canvasHeight);\n\t\t\t\tparticlesRef.current.forEach((p) => p.draw(context));\n\t\t\t}\n\n\t\t\tanimationFrameId.current = requestAnimationFrame(animate);\n\t\t};\n\n\t\t// Use ResizeObserver for efficient resize handling\n\t\tconst resizeObserver = new ResizeObserver((entries) => {\n\t\t\tif (!entries || entries.length === 0) return;\n\t\t\tconst { width, height } = entries[0].contentRect;\n\t\t\tsetup(width, height);\n\t\t});\n\n\t\tif (canvas.parentElement) {\n\t\t\tresizeObserver.observe(canvas.parentElement);\n\t\t}\n\n\t\t// Start the animation\n\t\tanimate(0);\n\n\t\t// Cleanup function to stop the animation and observer\n\t\treturn () => {\n\t\t\tif (animationFrameId.current) {\n\t\t\t\tcancelAnimationFrame(animationFrameId.current);\n\t\t\t}\n\t\t\tresizeObserver.disconnect();\n\t\t};\n\t}, [colors, speed, smooth, canvasRef, getRandomColorMemoized]); // Dependencies for the effect\n};\n\ninterface LetterGlitchProps {\n\tglitchColors: string[];\n\tglitchSpeed: number;\n\tsmooth: boolean;\n\tcenterVignette?: boolean;\n\touterVignette?: boolean;\n}\n\nconst LetterGlitch = ({\n\tglitchColors,\n\tglitchSpeed,\n\tsmooth,\n\tcenterVignette = false,\n\touterVignette = true,\n}: LetterGlitchProps) => {\n\tconst canvasRef = useRef<HTMLCanvasElement>(null);\n\n\t// The custom hook handles all the complex animation logic\n\tuseMatrixAnimation(canvasRef, {\n\t\tcolors: glitchColors,\n\t\tspeed: glitchSpeed,\n\t\tsmooth: smooth,\n\t});\n\n\treturn (\n\t\t<div className=\"relative w-full h-full bg-black overflow-hidden\">\n\t\t\t<canvas ref={canvasRef} className=\"block w-full h-full\" />\n\t\t\t{/* Vignette overlays for visual effect */}\n\t\t\t{outerVignette && (\n\t\t\t\t<div className=\"absolute inset-0 pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0)_60%,_rgba(0,0,0,1)_100%)]\"></div>\n\t\t\t)}\n\t\t\t{centerVignette && (\n\t\t\t\t<div className=\"absolute inset-0 pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0.8)_0%,_rgba(0,0,0,0)_60%)]\"></div>\n\t\t\t)}\n\t\t</div>\n\t);\n};\n\n// ================================================================================\n// Wrapper / Example Implementation\n// This component demonstrates how to use the MatrixRain component.\n// ================================================================================\nexport default function LetterGlitchWrapper() {\n\treturn (\n\t\t<div className=\"w-full h-[400px]\">\n\t\t\t<LetterGlitch\n\t\t\t\tglitchColors={[\n\t\t\t\t\t\"#32a852\", // green\n\t\t\t\t\t\"#4287f5\", // blue\n\t\t\t\t\t\"#d942f5\", // purple\n\t\t\t\t\t\"#f54242\", // red\n\t\t\t\t\t\"#f5e342\", // yellow\n\t\t\t\t\t\"#42f5f5\", // cyan\n\t\t\t\t\t\"#f5a142\", // orange\n\t\t\t\t]}\n\t\t\t\tglitchSpeed={50}\n\t\t\t\tsmooth={true}\n\t\t\t\touterVignette={true}\n\t\t\t\tcenterVignette={false}\n\t\t\t/>\n\t\t</div>\n\t);\n}\n",
      "type": "registry:component"
    },
    {
      "path": "letter-glitch",
      "content": "\"use client\";\nimport { useCallback, useEffect, useRef } from \"react\";\n\nconst FONT_SIZE = 16;\nconst CHAR_WIDTH = 10;\nconst CHAR_HEIGHT = 20;\nconst CHARACTER_SET =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*()-_{}[]:;<>,.?/\";\nclass Particle {\n\tx: number;\n\ty: number;\n\tchar: string;\n\tinitialColor: string;\n\tcurrentColor: string;\n\ttargetColor: string;\n\tcolorProgress: number;\n\n\tconstructor(\n\t\tx: number,\n\t\ty: number,\n\t\tchar: string,\n\t\tcolor: string,\n\t\ttargetColor: string,\n\t) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.char = char;\n\t\tthis.initialColor = color;\n\t\tthis.currentColor = color;\n\t\tthis.targetColor = targetColor;\n\t\tthis.colorProgress = 1.0; // Start fully at the initial color\n\t}\n\n\t// Draws the particle on the canvas\n\tdraw(ctx: CanvasRenderingContext2D) {\n\t\tctx.fillStyle = this.currentColor;\n\t\tctx.fillText(this.char, this.x, this.y);\n\t}\n\n\t// Assigns a new random character\n\trandomizeCharacter() {\n\t\tthis.char = CHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\n\t}\n\n\t// Sets a new target color to transition towards\n\tsetNewTargetColor(newColor: string, smooth: boolean) {\n\t\tif (!smooth) {\n\t\t\tthis.currentColor = newColor;\n\t\t\tthis.targetColor = newColor;\n\t\t\tthis.colorProgress = 1.0;\n\t\t} else {\n\t\t\tthis.initialColor = this.currentColor;\n\t\t\tthis.targetColor = newColor;\n\t\t\tthis.colorProgress = 0.0;\n\t\t}\n\t}\n\n\t// Updates the color transition if needed\n\tupdateColorTransition(): boolean {\n\t\tif (this.colorProgress >= 1) return false;\n\n\t\tthis.colorProgress = Math.min(this.colorProgress + 0.05, 1);\n\n\t\tconst start = ColorUtils.hexToRgb(this.initialColor);\n\t\tconst end = ColorUtils.hexToRgb(this.targetColor);\n\n\t\tif (start && end) {\n\t\t\tthis.currentColor = ColorUtils.interpolateRgb(\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tthis.colorProgress,\n\t\t\t);\n\t\t}\n\t\treturn true; // Indicates a change was made\n\t}\n}\n\n// ================================================================================\n// Utility Functions\n// A collection of pure helper functions.\n// ================================================================================\ninterface RgbColor {\n\tr: number;\n\tg: number;\n\tb: number;\n}\n\nconst ColorUtils = {\n\t// A different implementation of hex-to-rgb conversion\n\thexToRgb(hex: string): RgbColor | null {\n\t\tif (!hex || hex.charAt(0) !== \"#\") return null;\n\t\tconst cleanHex = hex.substring(1);\n\n\t\t// Handle 3-digit hex\n\t\tconst fullHex =\n\t\t\tcleanHex.length === 3\n\t\t\t\t? cleanHex\n\t\t\t\t\t\t.split(\"\")\n\t\t\t\t\t\t.map((c: string) => c + c)\n\t\t\t\t\t\t.join(\"\")\n\t\t\t\t: cleanHex;\n\n\t\tif (fullHex.length !== 6) return null;\n\n\t\treturn {\n\t\t\tr: parseInt(fullHex.substring(0, 2), 16),\n\t\t\tg: parseInt(fullHex.substring(2, 4), 16),\n\t\t\tb: parseInt(fullHex.substring(4, 6), 16),\n\t\t};\n\t},\n\t// Interpolates between two RGB colors\n\tinterpolateRgb(start: RgbColor, end: RgbColor, factor: number): string {\n\t\tconst r = Math.round(start.r + (end.r - start.r) * factor);\n\t\tconst g = Math.round(start.g + (end.g - start.g) * factor);\n\t\tconst b = Math.round(start.b + (end.b - start.b) * factor);\n\t\treturn `rgb(${r}, ${g}, ${b})`;\n\t},\n\t// Picks a random color from the provided array\n\tgetRandomColor(colors: string[]): string {\n\t\treturn colors[Math.floor(Math.random() * colors.length)];\n\t},\n};\n\ninterface AnimationOptions {\n\tcolors?: string[];\n\tspeed?: number;\n\tsmooth?: boolean;\n}\n\nconst useMatrixAnimation = (\n\tcanvasRef: React.RefObject<HTMLCanvasElement | null>,\n\toptions: AnimationOptions,\n) => {\n\tconst {\n\t\tcolors = [\"#2b4539\", \"#61dca3\", \"#61b3dc\"],\n\t\tspeed = 50,\n\t\tsmooth = true,\n\t} = options;\n\n\t// Using refs to store animation state without causing re-renders\n\tconst particlesRef = useRef<Particle[]>([]);\n\tconst animationFrameId = useRef<number | null>(null);\n\tconst lastUpdateTime = useRef<number>(0);\n\tconst contextRef = useRef<CanvasRenderingContext2D | null>(null);\n\n\t// Memoize the getRandomColor function to ensure stability\n\tconst getRandomColorMemoized = useCallback(\n\t\t() => ColorUtils.getRandomColor(colors),\n\t\t[colors],\n\t);\n\n\tuseEffect(() => {\n\t\tconst canvas = canvasRef.current;\n\t\tif (!canvas) return;\n\n\t\tconst context = canvas.getContext(\"2d\", { willReadFrequently: true });\n\t\tif (!context) return;\n\t\tcontextRef.current = context;\n\n\t\tconst grid = { cols: 0, rows: 0 };\n\n\t\t// This function initializes or re-initializes the particle grid\n\t\tconst setup = (width: number, height: number) => {\n\t\t\tconst dpr = window.devicePixelRatio || 1;\n\t\t\tcanvas.width = width * dpr;\n\t\t\tcanvas.height = height * dpr;\n\t\t\tcanvas.style.width = `${width}px`;\n\t\t\tcanvas.style.height = `${height}px`;\n\t\t\tcontext.setTransform(dpr, 0, 0, dpr, 0, 0);\n\n\t\t\tcontext.font = `${FONT_SIZE}px monospace`;\n\t\t\tcontext.textBaseline = \"top\";\n\n\t\t\tgrid.cols = Math.ceil(width / CHAR_WIDTH);\n\t\t\tgrid.rows = Math.ceil(height / CHAR_HEIGHT);\n\n\t\t\tparticlesRef.current = [];\n\t\t\tfor (let row = 0; row < grid.rows; row++) {\n\t\t\t\tfor (let col = 0; col < grid.cols; col++) {\n\t\t\t\t\tconst x = col * CHAR_WIDTH;\n\t\t\t\t\tconst y = row * CHAR_HEIGHT;\n\t\t\t\t\tconst char =\n\t\t\t\t\t\tCHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\n\t\t\t\t\tconst color = getRandomColorMemoized();\n\t\t\t\t\tconst targetColor = getRandomColorMemoized();\n\t\t\t\t\tparticlesRef.current.push(\n\t\t\t\t\t\tnew Particle(x, y, char, color, targetColor),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// The main animation loop\n\t\tconst animate = (timestamp: number) => {\n\t\t\tlet needsRedraw = false;\n\t\t\tconst elapsed = timestamp - lastUpdateTime.current;\n\n\t\t\t// Update a batch of particles based on the speed setting\n\t\t\tif (elapsed > speed) {\n\t\t\t\tconst updateCount = Math.max(\n\t\t\t\t\t1,\n\t\t\t\t\tMath.floor(particlesRef.current.length * 0.05),\n\t\t\t\t);\n\t\t\t\tfor (let i = 0; i < updateCount; i++) {\n\t\t\t\t\tconst index = Math.floor(Math.random() * particlesRef.current.length);\n\t\t\t\t\tconst particle = particlesRef.current[index];\n\t\t\t\t\tif (particle) {\n\t\t\t\t\t\tparticle.randomizeCharacter();\n\t\t\t\t\t\tparticle.setNewTargetColor(getRandomColorMemoized(), smooth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastUpdateTime.current = timestamp;\n\t\t\t\tneedsRedraw = true;\n\t\t\t}\n\n\t\t\t// Handle smooth color transitions for any active particles\n\t\t\tif (smooth) {\n\t\t\t\tparticlesRef.current.forEach((p) => {\n\t\t\t\t\tif (p.updateColorTransition()) {\n\t\t\t\t\t\tneedsRedraw = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Only redraw the canvas if something has changed\n\t\t\tif (needsRedraw) {\n\t\t\t\tconst canvasWidth = canvas.width / (window.devicePixelRatio || 1);\n\t\t\t\tconst canvasHeight = canvas.height / (window.devicePixelRatio || 1);\n\t\t\t\tcontext.clearRect(0, 0, canvasWidth, canvasHeight);\n\t\t\t\tparticlesRef.current.forEach((p) => p.draw(context));\n\t\t\t}\n\n\t\t\tanimationFrameId.current = requestAnimationFrame(animate);\n\t\t};\n\n\t\t// Use ResizeObserver for efficient resize handling\n\t\tconst resizeObserver = new ResizeObserver((entries) => {\n\t\t\tif (!entries || entries.length === 0) return;\n\t\t\tconst { width, height } = entries[0].contentRect;\n\t\t\tsetup(width, height);\n\t\t});\n\n\t\tif (canvas.parentElement) {\n\t\t\tresizeObserver.observe(canvas.parentElement);\n\t\t}\n\n\t\t// Start the animation\n\t\tanimate(0);\n\n\t\t// Cleanup function to stop the animation and observer\n\t\treturn () => {\n\t\t\tif (animationFrameId.current) {\n\t\t\t\tcancelAnimationFrame(animationFrameId.current);\n\t\t\t}\n\t\t\tresizeObserver.disconnect();\n\t\t};\n\t}, [colors, speed, smooth, canvasRef, getRandomColorMemoized]); // Dependencies for the effect\n};\n\ninterface LetterGlitchProps {\n\tglitchColors: string[];\n\tglitchSpeed: number;\n\tsmooth: boolean;\n\tcenterVignette?: boolean;\n\touterVignette?: boolean;\n}\n\nconst LetterGlitch = ({\n\tglitchColors,\n\tglitchSpeed,\n\tsmooth,\n\tcenterVignette = false,\n\touterVignette = true,\n}: LetterGlitchProps) => {\n\tconst canvasRef = useRef<HTMLCanvasElement>(null);\n\n\t// The custom hook handles all the complex animation logic\n\tuseMatrixAnimation(canvasRef, {\n\t\tcolors: glitchColors,\n\t\tspeed: glitchSpeed,\n\t\tsmooth: smooth,\n\t});\n\n\treturn (\n\t\t<div className=\"relative w-full h-full bg-black overflow-hidden\">\n\t\t\t<canvas ref={canvasRef} className=\"block w-full h-full\" />\n\t\t\t{/* Vignette overlays for visual effect */}\n\t\t\t{outerVignette && (\n\t\t\t\t<div className=\"absolute inset-0 pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0)_60%,_rgba(0,0,0,1)_100%)]\"></div>\n\t\t\t)}\n\t\t\t{centerVignette && (\n\t\t\t\t<div className=\"absolute inset-0 pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0.8)_0%,_rgba(0,0,0,0)_60%)]\"></div>\n\t\t\t)}\n\t\t</div>\n\t);\n};\n\n// ================================================================================\n// Wrapper / Example Implementation\n// This component demonstrates how to use the MatrixRain component.\n// ================================================================================\nexport default function LetterGlitchWrapper() {\n\treturn (\n\t\t<div className=\"w-full h-[400px]\">\n\t\t\t<LetterGlitch\n\t\t\t\tglitchColors={[\n\t\t\t\t\t\"#32a852\", // green\n\t\t\t\t\t\"#4287f5\", // blue\n\t\t\t\t\t\"#d942f5\", // purple\n\t\t\t\t\t\"#f54242\", // red\n\t\t\t\t\t\"#f5e342\", // yellow\n\t\t\t\t\t\"#42f5f5\", // cyan\n\t\t\t\t\t\"#f5a142\", // orange\n\t\t\t\t]}\n\t\t\t\tglitchSpeed={50}\n\t\t\t\tsmooth={true}\n\t\t\t\touterVignette={true}\n\t\t\t\tcenterVignette={false}\n\t\t\t/>\n\t\t</div>\n\t);\n}\n",
      "type": "registry:component"
    }
  ],
  "devDependencies": [],
  "registryDependencies": [],
  "cssVars": {
    "dark": {},
    "light": {}
  }
}