{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "glitchvault",
  "title": "Glitchvault",
  "description": "A minimalistic glitchvault component designed with React and Tailwind CSS.",
  "author": "Reche Soares",
  "type": "registry:ui",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "cssVars": {
    "dark": {},
    "light": {}
  },
  "files": [
    {
      "path": "glitchvault.tsx",
      "content": "import GlitchVault from \"./glitchvault\";\nexport default function GlitchVaultProfile() {\n\treturn (\n\t\t<main className=\"w-full  flex flex-col items-center justify-center p-4 relative overflow-hidden\">\n\t\t\t<div className=\"absolute inset-0\"></div>\n\t\t\t<GlitchVault\n\t\t\t\tclassName=\"w-full max-w-sm backdrop-blur-xl bg-white/20 dark:bg-black/20 border border-white/30 dark:border-white/10 rounded-2xl shadow-2xl shadow-cyan-500/10 relative z-10\"\n\t\t\t\tglitchColor=\"#0AF0F0\"\n\t\t\t\tglitchRadius={120}\n\t\t\t>\n\t\t\t\t<div className=\"p-8 text-center relative\">\n\t\t\t\t\t<div className=\"absolute inset-0 bg-gradient-to-b from-transparent via-white/5 to-transparent rounded-2xl\"></div>\n\t\t\t\t\t<div className=\"flex justify-center items-center mb-8 relative z-10\">\n\t\t\t\t\t\t<div className=\"w-28 h-28 bg-gradient-to-br from-cyan-400/20 to-blue-500/20 backdrop-blur-sm rounded-full flex items-center justify-center border border-white/20 shadow-lg shadow-cyan-500/20 group cursor-pointer hover:scale-105 transition-all duration-500\">\n\t\t\t\t\t\t\t<div className=\"w-24 h-24 bg-gradient-to-br from-cyan-500/10 to-blue-600/10 rounded-full flex items-center justify-center border border-white/10\">\n\t\t\t\t\t\t\t\t<span className=\"text-cyan-600 dark:text-cyan-300 text-sm font-medium opacity-70 group-hover:opacity-100 group-hover:scale-110 transition-all duration-300\">\n\t\t\t\t\t\t\t\t\tHover me\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<h2 className=\"text-3xl font-bold bg-gradient-to-r from-slate-800 via-slate-700 to-cyan-700 dark:from-white dark:via-slate-100 dark:to-cyan-300 bg-clip-text text-transparent mb-2 tracking-wide relative z-10\">\n\t\t\t\t\t\tAura\n\t\t\t\t\t</h2>\n\t\t\t\t\t<p className=\"text-slate-600/80 dark:text-slate-300/80 mb-8 text-sm font-medium relative z-10\">\n\t\t\t\t\t\tUI/UX Designer & Developer\n\t\t\t\t\t</p>\n\t\t\t\t\t<button className=\"bg-gradient-to-r from-cyan-500/10 via-blue-500/10 to-cyan-500/10 backdrop-blur-sm border border-cyan-400/30 text-cyan-700 dark:text-cyan-300 px-8 py-3 rounded-full hover:from-cyan-500/20 hover:via-blue-500/20 hover:to-cyan-500/20 hover:border-cyan-400/50 hover:shadow-lg hover:shadow-cyan-500/25 transition-all duration-300 font-medium relative z-10 hover:scale-105\">\n\t\t\t\t\t\tView Profile\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</GlitchVault>\n\t\t</main>\n\t);\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "glitchvault-card.tsx",
      "content": "import GlitchVault from \"./glitchvault\";\n\nexport default function GlitchVaultCard() {\n\treturn (\n\t\t<GlitchVault\n\t\t\tclassName=\"w-full max-w-md border border-slate-200 dark:border-slate-800 rounded-xl bg-white/50 dark:bg-slate-900/50 backdrop-blur-sm\"\n\t\t\tglitchColor=\"#FF6B6B\"\n\t\t\tglitchRadius={80}\n\t\t>\n\t\t\t<div className=\"p-6\">\n\t\t\t\t<div className=\"flex items-center gap-4 mb-4\">\n\t\t\t\t\t<div className=\"w-12 h-12 bg-gradient-to-br from-red-400 to-pink-500 rounded-lg flex items-center justify-center\">\n\t\t\t\t\t\t<span className=\"text-white font-bold text-lg\">ðŸš€</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h3 className=\"font-semibold text-slate-800 dark:text-slate-100\">\n\t\t\t\t\t\t\tProject Launch\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<p className=\"text-sm text-slate-600 dark:text-slate-400\">\n\t\t\t\t\t\t\tReady to deploy\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<p className=\"text-slate-700 dark:text-slate-300 text-sm mb-4\">\n\t\t\t\t\tYour application is ready for production deployment with all tests\n\t\t\t\t\tpassing.\n\t\t\t\t</p>\n\t\t\t\t<div className=\"flex gap-2\">\n\t\t\t\t\t<button className=\"bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors\">\n\t\t\t\t\t\tDeploy Now\n\t\t\t\t\t</button>\n\t\t\t\t\t<button className=\"border border-slate-300 dark:border-slate-600 text-slate-700 dark:text-slate-300 px-4 py-2 rounded-lg text-sm font-medium hover:bg-slate-50 dark:hover:bg-slate-800 transition-colors\">\n\t\t\t\t\t\tView Details\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</GlitchVault>\n\t);\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "glitchvault.tsx",
      "content": "\"use client\";\nimport React, { useCallback, useEffect, useMemo, useRef } from \"react\";\n\n// Type declarations for OffscreenCanvas (may not be available in all environments)\ndeclare global {\n\tinterface Window {\n\t\tOffscreenCanvas?: {\n\t\t\tnew (width: number, height: number): OffscreenCanvas;\n\t\t};\n\t}\n}\n\ninterface OffscreenCanvas {\n\twidth: number;\n\theight: number;\n\tgetContext(\n\t\tcontextId: \"2d\",\n\t\toptions?: CanvasRenderingContext2DSettings,\n\t): OffscreenCanvasRenderingContext2D | null;\n}\n\ninterface OffscreenCanvasRenderingContext2D {\n\tcanvas: OffscreenCanvas;\n\tclearRect(x: number, y: number, w: number, h: number): void;\n\tfillText(text: string, x: number, y: number): void;\n\tcreateRadialGradient(\n\t\tx0: number,\n\t\ty0: number,\n\t\tr0: number,\n\t\tx1: number,\n\t\ty1: number,\n\t\tr1: number,\n\t): CanvasGradient;\n\tfont: string;\n\ttextBaseline: CanvasTextBaseline;\n\tfillStyle: string | CanvasGradient | CanvasPattern;\n\tglobalAlpha: number;\n}\n\ninterface HexColor {\n\tr: number;\n\tg: number;\n\tb: number;\n}\n\ninterface MousePosition {\n\tx: number;\n\ty: number;\n}\n\ninterface GridDimensions {\n\tcols: number;\n\trows: number;\n}\n\ninterface MatrixAnimationOptions {\n\tglitchColor?: string;\n\tglitchRadius?: number;\n\tperformanceMode?: \"high\" | \"balanced\" | \"low\";\n}\n\ninterface LetterGlitchProps {\n\tglitchColor?: string;\n\tglitchRadius?: number;\n\tinteractionRef: React.RefObject<HTMLDivElement | null>;\n\tperformanceMode?: \"high\" | \"balanced\" | \"low\";\n}\n\ninterface GlitchVaultProps {\n\tchildren: React.ReactNode;\n\tclassName?: string;\n\tglitchColor?: string;\n\tglitchRadius?: number;\n\tperformanceMode?: \"high\" | \"balanced\" | \"low\";\n\tdisabled?: boolean;\n\ttheme?: \"light\" | \"dark\" | \"auto\";\n}\n\nconst FONT_SIZE = 16;\nconst CHAR_WIDTH = 10;\nconst CHAR_HEIGHT = 20;\nconst CHARACTER_SET =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*()-_{}[]:;<>,.?/\";\nconst PARTICLE_POOL_SIZE = 5000; // Pre-allocate particles\nconst RENDER_THROTTLE = 16; // Throttle rendering to ~60fps\n\n// Theme-specific color\n\nfunction hexToRgb(hex: string): HexColor | null {\n\tif (!hex) return null;\n\tconst shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n\thex = hex.replace(\n\t\tshorthandRegex,\n\t\t(_: string, r: string, g: string, b: string) => r + r + g + g + b + b,\n\t);\n\tconst result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\treturn result\n\t\t? {\n\t\t\t\tr: parseInt(result[1], 16),\n\t\t\t\tg: parseInt(result[2], 16),\n\t\t\t\tb: parseInt(result[3], 16),\n\t\t\t}\n\t\t: null;\n}\n\nclass Particle {\n\tx = 0;\n\ty = 0;\n\tchar = \"\";\n\topacity = 0;\n\ttargetOpacity = 0;\n\topacityVelocity = 0;\n\tlastUpdate = 0;\n\tisActive = false;\n\tisDirty = false;\n\n\treset(x: number, y: number, char: string): void {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.char = char;\n\t\tthis.opacity = 0;\n\t\tthis.targetOpacity = 0;\n\t\tthis.opacityVelocity = 0;\n\t\tthis.lastUpdate = performance.now();\n\t\tthis.isActive = true;\n\t\tthis.isDirty = false;\n\t}\n\n\tupdate(deltaTime: number): boolean {\n\t\tif (!this.isActive || Math.abs(this.opacity - this.targetOpacity) < 0.01) {\n\t\t\tif (this.opacity !== this.targetOpacity) {\n\t\t\t\tthis.opacity = this.targetOpacity;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tconst diff = this.targetOpacity - this.opacity;\n\t\tthis.opacityVelocity = diff * 0.15; // Smooth easing\n\t\tthis.opacity += this.opacityVelocity * (deltaTime / 16);\n\n\t\tif (Math.abs(this.opacity - this.targetOpacity) < 0.01) {\n\t\t\tthis.opacity = this.targetOpacity;\n\t\t}\n\n\t\tthis.isDirty = true;\n\t\treturn true;\n\t}\n\n\tsetTargetOpacity(target: number): void {\n\t\tif (this.targetOpacity !== target) {\n\t\t\tthis.targetOpacity = target;\n\t\t\tif (target > 0 && this.opacity === 0) {\n\t\t\t\tthis.randomizeCharacter();\n\t\t\t}\n\t\t}\n\t}\n\n\trandomizeCharacter(): void {\n\t\tthis.char = CHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\n\t\tthis.isDirty = true;\n\t}\n}\n\nclass ParticlePool {\n\tpool: Particle[] = [];\n\tactiveParticles = new Set<Particle>();\n\n\tconstructor(size: number) {\n\t\tfor (let i = 0; i < size; i++) {\n\t\t\tthis.pool.push(new Particle());\n\t\t}\n\t}\n\n\tacquire(x: number, y: number, char: string): Particle | null {\n\t\tconst particle = this.pool.pop();\n\t\tif (particle) {\n\t\t\tparticle.reset(x, y, char);\n\t\t\tthis.activeParticles.add(particle);\n\t\t\treturn particle;\n\t\t}\n\t\t// console.warn(\"Particle pool depleted.\");\n\t\treturn null;\n\t}\n\n\trelease(particle: Particle): void {\n\t\tparticle.isActive = false;\n\t\tthis.activeParticles.delete(particle);\n\t\tthis.pool.push(particle);\n\t}\n\n\tgetActiveParticles(): Particle[] {\n\t\treturn Array.from(this.activeParticles);\n\t}\n\n\tclear(): void {\n\t\tthis.activeParticles.forEach((p) => this.release(p));\n\t}\n}\n\nclass RenderingEngine {\n\tctx: CanvasRenderingContext2D;\n\toffscreenCanvas: OffscreenCanvas | null = null;\n\toffscreenCtx: OffscreenCanvasRenderingContext2D | null = null;\n\tlastRenderTime = 0;\n\trenderThrottle: number;\n\n\tconstructor(ctx: CanvasRenderingContext2D, throttle = RENDER_THROTTLE) {\n\t\tthis.ctx = ctx;\n\t\tthis.renderThrottle = throttle;\n\t\tthis.setupOffscreenCanvas();\n\t}\n\n\tsetupOffscreenCanvas(): void {\n\t\tif (typeof window !== \"undefined\" && window.OffscreenCanvas) {\n\t\t\tthis.offscreenCanvas = new window.OffscreenCanvas(\n\t\t\t\tthis.ctx.canvas.width,\n\t\t\t\tthis.ctx.canvas.height,\n\t\t\t);\n\t\t\tthis.offscreenCtx = this.offscreenCanvas.getContext(\"2d\", {\n\t\t\t\talpha: true,\n\t\t\t\tdesynchronized: true,\n\t\t\t});\n\n\t\t\tif (this.offscreenCtx) {\n\t\t\t\tthis.offscreenCtx.font = `${FONT_SIZE}px monospace`;\n\t\t\t\tthis.offscreenCtx.textBaseline = \"top\";\n\t\t\t}\n\t\t}\n\t}\n\n\trender(\n\t\tparticles: Particle[],\n\t\tglitchColor: string,\n\t\tforceRender = false,\n\t): void {\n\t\tconst now = performance.now();\n\t\tif (!forceRender && now - this.lastRenderTime < this.renderThrottle) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.lastRenderTime = now;\n\t\tconst renderCtx = this.offscreenCtx || this.ctx;\n\t\tconst baseColor = hexToRgb(glitchColor);\n\t\tif (!baseColor) return; // Exit if the color is invalid\n\n\t\trenderCtx.clearRect(0, 0, renderCtx.canvas.width, renderCtx.canvas.height);\n\n\t\tconst opacityBuckets = new Map<number, Particle[]>();\n\n\t\tparticles.forEach((particle) => {\n\t\t\tif (particle.opacity > 0.01) {\n\t\t\t\tconst bucketKey = Math.round(particle.opacity * 20) / 20; // Group in 5% increments\n\t\t\t\tif (!opacityBuckets.has(bucketKey)) {\n\t\t\t\t\topacityBuckets.set(bucketKey, []);\n\t\t\t\t}\n\t\t\t\topacityBuckets.get(bucketKey)!.push(particle);\n\t\t\t}\n\t\t});\n\n\t\topacityBuckets.forEach((bucket, opacity) => {\n\t\t\trenderCtx.globalAlpha = opacity;\n\n\t\t\tbucket.forEach((particle) => {\n\t\t\t\tconst gradient = renderCtx.createRadialGradient(\n\t\t\t\t\tparticle.x + CHAR_WIDTH / 2,\n\t\t\t\t\tparticle.y + CHAR_HEIGHT / 2,\n\t\t\t\t\t0,\n\t\t\t\t\tparticle.x + CHAR_WIDTH / 2,\n\t\t\t\t\tparticle.y + CHAR_HEIGHT / 2,\n\t\t\t\t\tCHAR_WIDTH * 1.5,\n\t\t\t\t);\n\n\t\t\t\tgradient.addColorStop(\n\t\t\t\t\t0,\n\t\t\t\t\t`rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 1)`,\n\t\t\t\t);\n\t\t\t\tgradient.addColorStop(\n\t\t\t\t\t0.5,\n\t\t\t\t\t`rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 0.5)`,\n\t\t\t\t);\n\t\t\t\tgradient.addColorStop(\n\t\t\t\t\t1,\n\t\t\t\t\t`rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 0)`,\n\t\t\t\t);\n\n\t\t\t\trenderCtx.fillStyle = gradient;\n\t\t\t\trenderCtx.fillText(particle.char, particle.x, particle.y);\n\t\t\t});\n\t\t});\n\n\t\tif (this.offscreenCanvas && this.offscreenCtx) {\n\t\t\tthis.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n\t\t\tthis.ctx.drawImage(\n\t\t\t\tthis.offscreenCanvas as unknown as CanvasImageSource,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t);\n\t\t}\n\t}\n\n\tresize(width: number, height: number): void {\n\t\tif (this.offscreenCanvas) {\n\t\t\tthis.offscreenCanvas.width = width;\n\t\t\tthis.offscreenCanvas.height = height;\n\t\t\tif (this.offscreenCtx) {\n\t\t\t\tthis.offscreenCtx.font = `${FONT_SIZE}px monospace`;\n\t\t\t\tthis.offscreenCtx.textBaseline = \"top\";\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst useMatrixAnimation = (\n\tcanvasRef: React.RefObject<HTMLCanvasElement | null>,\n\tinteractionRef: React.RefObject<HTMLDivElement | null>,\n\toptions: MatrixAnimationOptions,\n) => {\n\tconst {\n\t\tglitchColor = \"#00ffff\",\n\t\tglitchRadius = 100,\n\t\tperformanceMode = \"balanced\",\n\t} = options;\n\n\tconst particlePoolRef = useRef<ParticlePool | null>(null);\n\tconst renderingEngineRef = useRef<RenderingEngine | null>(null);\n\tconst animationFrameId = useRef<number | null>(null);\n\tconst mousePosRef = useRef<MousePosition | null>(null);\n\tconst lastFrameTime = useRef(0);\n\tconst gridRef = useRef<GridDimensions>({\n\t\tcols: 0,\n\t\trows: 0,\n\t});\n\n\tconst performanceSettings = useMemo(() => {\n\t\tswitch (performanceMode) {\n\t\t\tcase \"high\":\n\t\t\t\treturn {\n\t\t\t\t\tupdateInterval: 16,\n\t\t\t\t\trenderThrottle: 16,\n\t\t\t\t\tbatchSize: 200,\n\t\t\t\t};\n\t\t\tcase \"low\":\n\t\t\t\treturn {\n\t\t\t\t\tupdateInterval: 50,\n\t\t\t\t\trenderThrottle: 33,\n\t\t\t\t\tbatchSize: 50,\n\t\t\t\t};\n\t\t\tdefault:\n\t\t\t\treturn {\n\t\t\t\t\tupdateInterval: 33,\n\t\t\t\t\trenderThrottle: 16,\n\t\t\t\t\tbatchSize: 100,\n\t\t\t\t};\n\t\t}\n\t}, [performanceMode]);\n\n\tconst handleMouseMove = useCallback(\n\t\t(event: Event) => {\n\t\t\tconst mouseEvent = event as MouseEvent;\n\t\t\tconst interactionElement = interactionRef?.current;\n\t\t\tif (!interactionElement) return;\n\n\t\t\tconst rect = interactionElement.getBoundingClientRect();\n\t\t\tmousePosRef.current = {\n\t\t\t\tx: mouseEvent.clientX - rect.left,\n\t\t\t\ty: mouseEvent.clientY - rect.top,\n\t\t\t};\n\t\t},\n\t\t[interactionRef],\n\t);\n\n\tconst handleMouseLeave = useCallback(() => {\n\t\tmousePosRef.current = null;\n\t}, []);\n\n\tuseEffect(() => {\n\t\tconst canvas = canvasRef.current;\n\t\tconst interactionElement = interactionRef?.current || canvas;\n\t\tif (!canvas || !interactionElement) return;\n\n\t\tconst context = canvas.getContext(\"2d\", {\n\t\t\talpha: true,\n\t\t\tdesynchronized: true,\n\t\t\twillReadFrequently: false,\n\t\t});\n\t\tif (!context) return;\n\n\t\tparticlePoolRef.current = new ParticlePool(PARTICLE_POOL_SIZE);\n\t\trenderingEngineRef.current = new RenderingEngine(\n\t\t\tcontext,\n\t\t\tperformanceSettings.renderThrottle,\n\t\t);\n\n\t\tconst setup = (width: number, height: number) => {\n\t\t\tconst dpr = window.devicePixelRatio || 1;\n\t\t\tcanvas.width = width * dpr;\n\t\t\tcanvas.height = height * dpr;\n\t\t\tcanvas.style.width = `${width}px`;\n\t\t\tcanvas.style.height = `${height}px`;\n\t\t\tcontext.setTransform(dpr, 0, 0, dpr, 0, 0);\n\n\t\t\tcontext.font = `${FONT_SIZE}px monospace`;\n\t\t\tcontext.textBaseline = \"top\";\n\n\t\t\tgridRef.current.cols = Math.ceil(width / CHAR_WIDTH);\n\t\t\tgridRef.current.rows = Math.ceil(height / CHAR_HEIGHT);\n\n\t\t\tparticlePoolRef.current?.clear();\n\n\t\t\tfor (let row = 0; row < gridRef.current.rows; row++) {\n\t\t\t\tfor (let col = 0; col < gridRef.current.cols; col++) {\n\t\t\t\t\tconst x = col * CHAR_WIDTH;\n\t\t\t\t\tconst y = row * CHAR_HEIGHT;\n\t\t\t\t\tconst char =\n\t\t\t\t\t\tCHARACTER_SET[Math.floor(Math.random() * CHARACTER_SET.length)];\n\t\t\t\t\tparticlePoolRef.current?.acquire(x, y, char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trenderingEngineRef.current?.resize(canvas.width, canvas.height);\n\t\t};\n\n\t\tconst animate = (currentTime: number) => {\n\t\t\tconst deltaTime = currentTime - lastFrameTime.current;\n\n\t\t\tif (deltaTime >= performanceSettings.updateInterval) {\n\t\t\t\tconst particles = particlePoolRef.current?.getActiveParticles() || [];\n\t\t\t\tconst mousePos = mousePosRef.current;\n\t\t\t\tlet needsRender = false;\n\n\t\t\t\tfor (\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\ti < particles.length;\n\t\t\t\t\ti += performanceSettings.batchSize\n\t\t\t\t) {\n\t\t\t\t\tconst batch = particles.slice(i, i + performanceSettings.batchSize);\n\n\t\t\t\t\tbatch.forEach((particle) => {\n\t\t\t\t\t\tlet targetOpacity = 0;\n\n\t\t\t\t\t\tif (mousePos) {\n\t\t\t\t\t\t\tconst dx = particle.x - mousePos.x + CHAR_WIDTH / 2;\n\t\t\t\t\t\t\tconst dy = particle.y - mousePos.y + CHAR_HEIGHT / 2;\n\t\t\t\t\t\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\t\t\t\tif (distance < glitchRadius) {\n\t\t\t\t\t\t\t\ttargetOpacity = 1 - distance / glitchRadius;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparticle.setTargetOpacity(targetOpacity);\n\t\t\t\t\t\tif (particle.update(deltaTime)) {\n\t\t\t\t\t\t\tneedsRender = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (needsRender && renderingEngineRef.current) {\n\t\t\t\t\trenderingEngineRef.current.render(particles, glitchColor);\n\t\t\t\t}\n\n\t\t\t\tlastFrameTime.current = currentTime;\n\t\t\t}\n\n\t\t\tanimationFrameId.current = requestAnimationFrame(animate);\n\t\t};\n\n\t\tinteractionElement.addEventListener(\"mousemove\", handleMouseMove, {\n\t\t\tpassive: true,\n\t\t});\n\t\tinteractionElement.addEventListener(\"mouseleave\", handleMouseLeave, {\n\t\t\tpassive: true,\n\t\t});\n\n\t\tconst resizeObserver = new ResizeObserver((entries) => {\n\t\t\tif (!entries || entries.length === 0) return;\n\t\t\tconst { width, height } = entries[0].contentRect;\n\t\t\tsetup(width, height);\n\t\t});\n\n\t\tif (canvas.parentElement) {\n\t\t\tresizeObserver.observe(canvas.parentElement);\n\t\t}\n\n\t\tlastFrameTime.current = performance.now();\n\t\tanimate(lastFrameTime.current);\n\n\t\treturn () => {\n\t\t\tinteractionElement.removeEventListener(\"mousemove\", handleMouseMove);\n\t\t\tinteractionElement.removeEventListener(\"mouseleave\", handleMouseLeave);\n\t\t\tif (animationFrameId.current) {\n\t\t\t\tcancelAnimationFrame(animationFrameId.current);\n\t\t\t}\n\t\t\tresizeObserver.disconnect();\n\t\t\tparticlePoolRef.current?.clear();\n\t\t};\n\t}, [\n\t\tglitchColor,\n\t\tglitchRadius,\n\t\thandleMouseMove,\n\t\thandleMouseLeave,\n\t\tcanvasRef,\n\t\tinteractionRef,\n\t\tperformanceSettings,\n\t]);\n};\n\nconst LetterGlitch = React.memo<LetterGlitchProps>(\n\t({\n\t\tglitchColor,\n\t\tglitchRadius,\n\t\tinteractionRef,\n\t\tperformanceMode = \"balanced\",\n\t}) => {\n\t\tconst canvasRef = useRef<HTMLCanvasElement>(null);\n\n\t\tuseMatrixAnimation(canvasRef, interactionRef, {\n\t\t\tglitchColor,\n\t\t\tglitchRadius,\n\t\t\tperformanceMode,\n\t\t});\n\n\t\treturn <canvas ref={canvasRef} className=\"block w-full h-full\" />;\n\t},\n);\n\nLetterGlitch.displayName = \"LetterGlitch\";\n\nconst GlitchVault = React.memo<GlitchVaultProps>(\n\t({\n\t\tchildren,\n\t\tclassName,\n\t\tglitchColor = \"#0AF0F0\",\n\t\tglitchRadius = 120,\n\t\tperformanceMode = \"balanced\",\n\t\tdisabled = false,\n\t}) => {\n\t\tconst interactionRef = useRef<HTMLDivElement>(null);\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tref={interactionRef}\n\t\t\t\tclassName={`relative rounded-2xl overflow-hidden ${className}`}\n\t\t\t>\n\t\t\t\t{!disabled && (\n\t\t\t\t\t<div className=\"absolute inset-0 z-0\">\n\t\t\t\t\t\t<LetterGlitch\n\t\t\t\t\t\t\tinteractionRef={interactionRef}\n\t\t\t\t\t\t\tglitchColor={glitchColor}\n\t\t\t\t\t\t\tglitchRadius={glitchRadius}\n\t\t\t\t\t\t\tperformanceMode={performanceMode}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t\t<div className=\"relative z-20\"> {children} </div>\n\t\t\t</div>\n\t\t);\n\t},\n);\nGlitchVault.displayName = \"GlitchVault\";\nexport default GlitchVault;\n",
      "type": "registry:ui"
    }
  ]
}