{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "fuzzy",
  "title": "Fuzzy",
  "description": "A minimalistic fuzzy search component designed with React and Tailwind CSS.",
  "author": "Reche Soares",
  "type": "registry:ui",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "cssVars": {
    "dark": {},
    "light": {}
  },
  "files": [
    {
      "path": "fuzzy.tsx",
      "content": "\"use client\";\nimport type React from \"react\";\nimport { useEffect, useMemo, useRef } from \"react\";\n\ninterface HoverGlitchProps {\n\ttext: string;\n\tfontFamily?: string;\n\tfontSize?: string;\n\tfontWeight?: number;\n\tcolor?: string;\n\tbaseIntensity?: number;\n\thoverIntensity?: number;\n\tletterSpacing?: string;\n\twordSpacing?: string;\n}\n\nconst HoverGlitch: React.FC<HoverGlitchProps> = ({\n\ttext,\n\tfontFamily = \"'Major Mono Display', monospace\",\n\tfontSize = \"10rem\",\n\tfontWeight = 400,\n\tcolor = \"#33ffcc\",\n\tbaseIntensity = 1,\n\thoverIntensity = 15,\n\tletterSpacing = \"0px\",\n\twordSpacing = \"0px\",\n}) => {\n\tconst canvasRef = useRef<HTMLCanvasElement>(null);\n\tconst animationFrameId = useRef<number | null>(null);\n\tconst currentIntensity = useRef(baseIntensity);\n\n\tconst font = useMemo(\n\t\t() => `${fontWeight} ${fontSize} ${fontFamily}`,\n\t\t[fontWeight, fontSize, fontFamily],\n\t);\n\n\tuseEffect(() => {\n\t\tcurrentIntensity.current = baseIntensity;\n\n\t\tconst canvas = canvasRef.current;\n\t\tif (!canvas) return;\n\n\t\tconst ctx = canvas.getContext(\"2d\", { willReadFrequently: true });\n\t\tif (!ctx) return;\n\n\t\tlet isCancelled = false;\n\n\t\tconst offscreenCanvas = document.createElement(\"canvas\");\n\t\tconst offscreenCtx = offscreenCanvas.getContext(\"2d\", {\n\t\t\twillReadFrequently: true,\n\t\t});\n\t\tif (!offscreenCtx) return;\n\n\t\tconst setupAndAnimate = async () => {\n\t\t\tawait document.fonts.ready;\n\t\t\tif (isCancelled) return;\n\n\t\t\toffscreenCtx.font = font;\n\t\t\tconst metrics = offscreenCtx.measureText(text);\n\t\t\tconst textWidth = Math.ceil(metrics.width);\n\t\t\tconst textHeight = Math.ceil(\n\t\t\t\tmetrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent,\n\t\t\t);\n\n\t\t\tconst horizontalPadding = hoverIntensity * 2;\n\t\t\tconst verticalPadding = 20;\n\t\t\tconst canvasWidth = textWidth + horizontalPadding;\n\t\t\tconst canvasHeight = textHeight + verticalPadding;\n\n\t\t\tcanvas.width = offscreenCanvas.width = canvasWidth;\n\t\t\tcanvas.height = offscreenCanvas.height = canvasHeight;\n\n\t\t\toffscreenCtx.font = font;\n\t\t\toffscreenCtx.fillStyle = color;\n\t\t\toffscreenCtx.textBaseline = \"top\";\n\t\t\toffscreenCtx.fillText(text, horizontalPadding / 2, verticalPadding / 2);\n\n\t\t\tconst sourceImageData = offscreenCtx.getImageData(\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tcanvasWidth,\n\t\t\t\tcanvasHeight,\n\t\t\t);\n\t\t\tconst sourcePixels = sourceImageData.data;\n\n\t\t\tconst renderLoop = () => {\n\t\t\t\tif (isCancelled || !ctx) return;\n\n\t\t\t\tconst destinationImageData = ctx.createImageData(\n\t\t\t\t\tcanvasWidth,\n\t\t\t\t\tcanvasHeight,\n\t\t\t\t);\n\t\t\t\tconst destinationPixels = destinationImageData.data;\n\n\t\t\t\tfor (let y = 0; y < canvasHeight; y++) {\n\t\t\t\t\tconst rowOffset = (Math.random() - 0.5) * currentIntensity.current;\n\t\t\t\t\tfor (let x = 0; x < canvasWidth; x++) {\n\t\t\t\t\t\tconst sourceX = Math.round(x + rowOffset);\n\t\t\t\t\t\tif (sourceX >= 0 && sourceX < canvasWidth) {\n\t\t\t\t\t\t\tconst destIndex = (y * canvasWidth + x) * 4;\n\t\t\t\t\t\t\tconst sourceIndex = (y * canvasWidth + sourceX) * 4;\n\n\t\t\t\t\t\t\tdestinationPixels[destIndex] = sourcePixels[sourceIndex];\n\t\t\t\t\t\t\tdestinationPixels[destIndex + 1] = sourcePixels[sourceIndex + 1];\n\t\t\t\t\t\t\tdestinationPixels[destIndex + 2] = sourcePixels[sourceIndex + 2];\n\t\t\t\t\t\t\tdestinationPixels[destIndex + 3] = sourcePixels[sourceIndex + 3];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\t\t\t\tctx.putImageData(destinationImageData, 0, 0);\n\t\t\t\tanimationFrameId.current = requestAnimationFrame(renderLoop);\n\t\t\t};\n\n\t\t\trenderLoop();\n\t\t};\n\n\t\tconst handleMouseEnter = () => {\n\t\t\tcurrentIntensity.current = hoverIntensity;\n\t\t};\n\t\tconst handleMouseLeave = () => {\n\t\t\tcurrentIntensity.current = baseIntensity;\n\t\t};\n\n\t\tconst handleTouchStart = () => {\n\t\t\tcurrentIntensity.current = hoverIntensity;\n\t\t};\n\t\tconst handleTouchEnd = () => {\n\t\t\tcurrentIntensity.current = baseIntensity;\n\t\t};\n\n\t\tcanvas.addEventListener(\"mouseenter\", handleMouseEnter);\n\t\tcanvas.addEventListener(\"mouseleave\", handleMouseLeave);\n\t\tcanvas.addEventListener(\"touchstart\", handleTouchStart, { passive: true });\n\t\tcanvas.addEventListener(\"touchend\", handleTouchEnd, { passive: true });\n\n\t\tsetupAndAnimate();\n\n\t\treturn () => {\n\t\t\tisCancelled = true;\n\t\t\tif (animationFrameId.current) {\n\t\t\t\tcancelAnimationFrame(animationFrameId.current);\n\t\t\t}\n\t\t\tcanvas.removeEventListener(\"mouseenter\", handleMouseEnter);\n\t\t\tcanvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n\t\t\tcanvas.removeEventListener(\"touchstart\", handleTouchStart);\n\t\t\tcanvas.removeEventListener(\"touchend\", handleTouchEnd);\n\t\t};\n\t}, [\n\t\ttext,\n\t\tfont,\n\t\tcolor,\n\t\tbaseIntensity,\n\t\thoverIntensity,\n\t\tletterSpacing,\n\t\twordSpacing,\n\t]);\n\n\treturn <canvas ref={canvasRef} style={{ maxWidth: \"100%\" }} />;\n};\n\nexport default function FuzzyText() {\n\treturn (\n\t\t<div className=\"w-full flex flex-col items-center justify-center p-4 text-center font-mono select-none\">\n\t\t\t<HoverGlitch\n\t\t\t\ttext=\"HOVER\"\n\t\t\t\tfontFamily=\"'Major Mono Display', monospace\"\n\t\t\t\tfontSize=\"clamp(5rem, 20vw, 17rem)\"\n\t\t\t\tfontWeight={700}\n\t\t\t\tcolor=\"#D7D00F\"\n\t\t\t\tbaseIntensity={6}\n\t\t\t\thoverIntensity={20}\n\t\t\t\tletterSpacing=\"-0.05em\"\n\t\t\t\twordSpacing=\"-0.1em\"\n\t\t\t/>\n\t\t</div>\n\t);\n}\n",
      "type": "registry:ui"
    }
  ]
}