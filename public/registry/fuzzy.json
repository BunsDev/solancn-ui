{
	"$schema": "https://ui.shadcn.com/schema/registry-item.json",
	"name": "fuzzy",
	"title": "Fuzzy",
	"description": "A minimalistic fuzzy search component designed with React and Tailwind CSS.",
	"author": "Reche Soares",
	"type": "registry:ui",
	"dependencies": [],
	"devDependencies": [],
	"registryDependencies": [],
	"cssVars": {
		"dark": {},
		"light": {}
	},
	"files": [
		{
			"path": "fuzzy.tsx",
			"content": "\"use client\";\nimport React, { useRef, useEffect, useMemo } from \"react\";\n\ninterface HoverGlitchProps {\n  text: string;\n  fontFamily?: string;\n  fontSize?: string;\n  fontWeight?: number;\n  color?: string;\n  baseIntensity?: number;\n  hoverIntensity?: number;\n  letterSpacing?: string;\n  wordSpacing?: string;\n}\n\nconst HoverGlitch: React.FC<HoverGlitchProps> = ({\n  text,\n  fontFamily = \"'Major Mono Display', monospace\",\n  fontSize = \"10rem\",\n  fontWeight = 400,\n  color = \"#33ffcc\",\n  baseIntensity = 1,\n  hoverIntensity = 15,\n  letterSpacing = \"0px\",\n  wordSpacing = \"0px\",\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const animationFrameId = useRef<number | null>(null);\n  const currentIntensity = useRef(baseIntensity);\n\n  const font = useMemo(\n    () => `${fontWeight} ${fontSize} ${fontFamily}`,\n    [fontWeight, fontSize, fontFamily]\n  );\n\n  useEffect(() => {\n    currentIntensity.current = baseIntensity;\n\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\", { willReadFrequently: true });\n    if (!ctx) return;\n\n    let isCancelled = false;\n\n    const offscreenCanvas = document.createElement(\"canvas\");\n    const offscreenCtx = offscreenCanvas.getContext(\"2d\", {\n      willReadFrequently: true,\n    });\n    if (!offscreenCtx) return;\n\n    const setupAndAnimate = async () => {\n      await document.fonts.ready;\n      if (isCancelled) return;\n\n      offscreenCtx.font = font;\n      const metrics = offscreenCtx.measureText(text);\n      const textWidth = Math.ceil(metrics.width);\n      const textHeight = Math.ceil(\n        metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n      );\n\n      const horizontalPadding = hoverIntensity * 2;\n      const verticalPadding = 20;\n      const canvasWidth = textWidth + horizontalPadding;\n      const canvasHeight = textHeight + verticalPadding;\n\n      canvas.width = offscreenCanvas.width = canvasWidth;\n      canvas.height = offscreenCanvas.height = canvasHeight;\n\n      offscreenCtx.font = font;\n      offscreenCtx.fillStyle = color;\n      offscreenCtx.textBaseline = \"top\";\n      offscreenCtx.fillText(text, horizontalPadding / 2, verticalPadding / 2);\n\n      const sourceImageData = offscreenCtx.getImageData(\n        0,\n        0,\n        canvasWidth,\n        canvasHeight\n      );\n      const sourcePixels = sourceImageData.data;\n\n      const renderLoop = () => {\n        if (isCancelled || !ctx) return;\n\n        const destinationImageData = ctx.createImageData(\n          canvasWidth,\n          canvasHeight\n        );\n        const destinationPixels = destinationImageData.data;\n\n        for (let y = 0; y < canvasHeight; y++) {\n          const rowOffset = (Math.random() - 0.5) * currentIntensity.current;\n          for (let x = 0; x < canvasWidth; x++) {\n            const sourceX = Math.round(x + rowOffset);\n            if (sourceX >= 0 && sourceX < canvasWidth) {\n              const destIndex = (y * canvasWidth + x) * 4;\n              const sourceIndex = (y * canvasWidth + sourceX) * 4;\n\n              destinationPixels[destIndex] = sourcePixels[sourceIndex];\n              destinationPixels[destIndex + 1] = sourcePixels[sourceIndex + 1];\n              destinationPixels[destIndex + 2] = sourcePixels[sourceIndex + 2];\n              destinationPixels[destIndex + 3] = sourcePixels[sourceIndex + 3];\n            }\n          }\n        }\n\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        ctx.putImageData(destinationImageData, 0, 0);\n        animationFrameId.current = requestAnimationFrame(renderLoop);\n      };\n\n      renderLoop();\n    };\n\n    const handleMouseEnter = () => {\n      currentIntensity.current = hoverIntensity;\n    };\n    const handleMouseLeave = () => {\n      currentIntensity.current = baseIntensity;\n    };\n\n    const handleTouchStart = () => {\n      currentIntensity.current = hoverIntensity;\n    };\n    const handleTouchEnd = () => {\n      currentIntensity.current = baseIntensity;\n    };\n\n    canvas.addEventListener(\"mouseenter\", handleMouseEnter);\n    canvas.addEventListener(\"mouseleave\", handleMouseLeave);\n    canvas.addEventListener(\"touchstart\", handleTouchStart, { passive: true });\n    canvas.addEventListener(\"touchend\", handleTouchEnd, { passive: true });\n\n    setupAndAnimate();\n\n    return () => {\n      isCancelled = true;\n      if (animationFrameId.current) {\n        cancelAnimationFrame(animationFrameId.current);\n      }\n      canvas.removeEventListener(\"mouseenter\", handleMouseEnter);\n      canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n      canvas.removeEventListener(\"touchstart\", handleTouchStart);\n      canvas.removeEventListener(\"touchend\", handleTouchEnd);\n    };\n  }, [\n    text,\n    font,\n    color,\n    baseIntensity,\n    hoverIntensity,\n    letterSpacing,\n    wordSpacing,\n  ]);\n\n  return <canvas ref={canvasRef} style={{ maxWidth: \"100%\" }} />;\n};\n\nexport default function FuzzyText() {\n  return (\n    <div className=\"w-full flex flex-col items-center justify-center p-4 text-center font-mono select-none\">\n      <HoverGlitch\n        text=\"HOVER\"\n        fontFamily=\"'Major Mono Display', monospace\"\n        fontSize=\"clamp(5rem, 20vw, 17rem)\"\n        fontWeight={700}\n        color=\"#D7D00F\"\n        baseIntensity={6}\n        hoverIntensity={20}\n        letterSpacing=\"-0.05em\"\n        wordSpacing=\"-0.1em\"\n      />\n    </div>\n  );\n}\n",
			"type": "registry:ui"
		}
	]
}
